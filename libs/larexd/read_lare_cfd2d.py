"""
Author
Lucas A. Tarr
ltarr@nso.edu
NSO, Maui, HI

Routines for reading and processing *.cfd files generated by LaRe2D
Note that LaRe version >=3 use a different output format, *.SDF files.

Adapted from original code at
https://raw.githubusercontent.com/mbareford/rs-shock-heating-paper/master/scripts/python/lare3d_cfd.py

Original LaRe paper by Arber+2001, JCP: 
https://ui.adsabs.harvard.edu/abs/2001JCoPh.171..151A/abstract

Most recent academic website:
https://warwick.ac.uk/fac/sci/physics/research/cfsa/people/tda/larexd/

Github repository (version 4 of LaRe, also using *.SDF files)
https://github.com/Warwick-Plasma/Lare3d 


LAT: I plan to release (some version of) this file when I publish my next paper describing data
driven simulations using LaRe, likely Tarr+2022 ApJ.

"""

import struct
import numpy as np


def read_lare_cfd2d(filename, key="all", verbose=False, **kwargs):
    char_size   = 1
    int_size    = 4
    long_size   = 8
    dbl_size    = 8
    hdr_tag_len = 3
    
    cfd = open(filename, 'rb')
    # process file header
    #################################################################
    hdr_tag      = cfd.read(hdr_tag_len)        
    hdr_size     = struct.unpack_from('i', cfd.read(int_size))[0]                
    blk_hdr_size = struct.unpack_from('i', cfd.read(int_size))[0]
    cfd_ver      = struct.unpack_from('i', cfd.read(int_size))[0]
    cfd_rev      = struct.unpack_from('i', cfd.read(int_size))[0]
    max_str_len  = struct.unpack_from('i', cfd.read(int_size))[0]
    nblocks      = struct.unpack_from('i', cfd.read(int_size))[0]

    
    if verbose:
        print( 'Header tag: ', hdr_tag)
        print( 'Header size: ', hdr_size)
        print( 'Block header size: ', blk_hdr_size)
        print( 'CFD version: ', cfd_ver)
        print( 'CFD revision: ', cfd_rev)
        print( 'Max str len: ', max_str_len)
        print( 'nblocks: ', nblocks    )
        print(' ')


    # process first block (time)
    ######################################################################
    tm_blk_name     = cfd.read(max_str_len)
    tm_blk_class    = cfd.read(max_str_len)
    tm_blk_type     = struct.unpack_from('i', cfd.read(int_size))[0]
    tm_blk_len      = struct.unpack_from('l', cfd.read(long_size))[0]
    tm_blk_meta_len = struct.unpack_from('l', cfd.read(long_size))[0]
    
    step = struct.unpack_from('i', cfd.read(int_size))[0]
    time = struct.unpack_from('d', cfd.read(dbl_size))[0]

    if verbose:
        print( 'Time block name: ', tm_blk_name.decode('utf8'))
        print( 'Time block class: ', tm_blk_class.decode('utf8'))
        print( 'Time block type: ', tm_blk_type)
        print( 'Time block len: ', tm_blk_len)
        print( 'Time block meta len: ', tm_blk_meta_len)
        print( 'Step: ', step)
        print( 'Time: ', time)
    ######################################################################
    
    
    # process second block (grid)
    ##############################################################################################################
    grd_blk_name     = cfd.read(max_str_len)
    grd_blk_class    = cfd.read(max_str_len)
    grd_blk_type     = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_blk_len      = struct.unpack_from('l', cfd.read(long_size))[0]
    grd_blk_meta_len = struct.unpack_from('l', cfd.read(long_size))[0]
    
    grd_type         = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_dim          = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_field_size   = struct.unpack_from('i', cfd.read(int_size))[0]    
    grd_nx           = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_ny           = struct.unpack_from('i', cfd.read(int_size))[0]
    #    grd_nz = struct.unpack_from('i', cfd.read(int_size))[0]    
    grd_x_min        = struct.unpack_from('d', cfd.read(dbl_size))[0]
    grd_x_max        = struct.unpack_from('d', cfd.read(dbl_size))[0]
    grd_y_min        = struct.unpack_from('d', cfd.read(dbl_size))[0]
    grd_y_max        = struct.unpack_from('d', cfd.read(dbl_size))[0]
    #    grd_z_min = struct.unpack_from('d', cfd.read(dbl_size))[0]
    #    grd_z_max = struct.unpack_from('d', cfd.read(dbl_size))[0]
    
    x = struct.unpack_from(str(eval('grd_nx')) + 'd', cfd.read(dbl_size*grd_nx))
    y = struct.unpack_from(str(eval('grd_ny')) + 'd', cfd.read(dbl_size*grd_ny))
    
    grd_blk_meta_len = grd_blk_len + (grd_nx + grd_ny )*grd_field_size
    if verbose:
        print('Grid type: ', grd_type)
        print('Grid dim: ', grd_dim)
        print('Grid field size: ', grd_field_size    )
        print('Grid nx: ', grd_nx)
        print('Grid ny: ', grd_ny)
        print('Grid x min: ', grd_x_min)
        print('Grid x max: ', grd_x_max)
        print('Grid y min: ', grd_y_min)
        print('Grid y max: ', grd_y_max)

    x  = np.array(x)
    y  = np.array(y)
    nx = len(x)
    ny = len(y)
    xc = (x[1:]+x[0:-1])/2
    yc = (y[1:]+y[0:-1])/2
    
    ### now start unpacking the data

    allblkdata = {}
    for i in range(2, nblocks):
        var_blk_name     = cfd.read(max_str_len).decode('utf8').rstrip()[:-1].lower()
        var_blk_class    = cfd.read(max_str_len).decode('utf8').rstrip()[:-1]
        var_blk_type     = struct.unpack_from('i', cfd.read(int_size))[0]
        var_blk_len      = struct.unpack_from('l', cfd.read(long_size))[0]
        var_blk_meta_len = struct.unpack_from('l', cfd.read(long_size))[0]
        
        var_type         = struct.unpack_from('i', cfd.read(int_size))[0]
        var_dim          = struct.unpack_from('i', cfd.read(int_size))[0]
        var_field_size   = struct.unpack_from('i', cfd.read(int_size))[0]
        
        var_nx = struct.unpack_from('i', cfd.read(int_size))[0]
        var_ny = struct.unpack_from('i', cfd.read(int_size))[0]
        
        var_stag_x     = struct.unpack_from('d', cfd.read(dbl_size))[0]
        var_stag_y     = struct.unpack_from('d', cfd.read(dbl_size))[0]
        var_min        = struct.unpack_from('d', cfd.read(dbl_size))[0]
        var_max        = struct.unpack_from('d', cfd.read(dbl_size))[0]    
        var_mesh_name  = cfd.read(max_str_len)
        var_mesh_class = cfd.read(max_str_len)
        #var_data = struct.unpack_from(str(eval('var_nz*var_nx*var_ny')) + 'd', cfd.read(var_field_size*(var_nz*var_nx*var_ny)))
        var_data = np.reshape(struct.unpack_from(str(eval('var_nx*var_ny')) + 'd', cfd.read(var_field_size*(var_nx*var_ny))),(var_ny, var_nx))
        if var_blk_name == key or key == "all":
            allblkdata[var_blk_name]=var_data
        else:
            allblkdata[var_blk_name]= np.array([0.])
        
    alldtypes = [np.dtype((x.dtype, x.shape)) for x in (np.array([filename]),np.array([time]),np.array([step]), 
                                                        np.array([nx]),np.array([ny]),np.array(x),np.array(y), 
                                                        np.array(xc),np.array(yc) )]
    
    alldtypes = alldtypes+[np.dtype((x.dtype,x.shape) )for x in allblkdata.values()]
    
    
    allnames = ('filename','time','step','nx','ny','x','y','xc','yc')+tuple(allblkdata.keys())
    
    print("Here's the list of available data in the CFD file:", allblkdata.keys())
        
    out = np.recarray(1, dtype={'names':allnames,'formats':alldtypes})
    
    out['filename'] = filename
    out['time']     = time
    out['step']     = step
    out['x']        = x
    out['y']        = y
    out['nx']       = nx
    out['ny']       = ny
    out['xc']       = xc
    out['yc']       = yc
    if key == "all":
        for k in allblkdata.keys():
            out[k]=allblkdata[k]
    elif key in allblkdata.keys():
        out[key] = allblkdata[key]
    else:
        pass
    cfd.close()
    del(allblkdata)
    return out

       
## DO SOMETHING LIKE THE FOLLOWING FOR SUBSAMPLING
    # y_max_i = 250
    # y_min_i = 50
    # cfd.seek(long(y_min_i)*var_nx*var_field_size, 1)
    # var_data1 = struct.unpack_from(str(eval('long(y_max_i-y_min_i+1)*var_nx')) + 'd', cfd.read(var_field_size*(long(y_max_i-y_min_i+1)*var_nx)))
    # cfd.seek(long(var_ny-y_max_i-1)*var_nx*var_field_size, 1)
    # var_ny = y_max_i-y_min_i+1
    # var_min = min(var_data)
    # var_max = max(var_data)
    # var_blk_meta_len = var_blk_len + (var_nx*var_ny)*var_field_size

    ## some stuff to show data
#        out1 = np.asarray(var_data1)
#    plt.imshow(  out1.reshape((-1,1025)), interpolation='nearest')
# plt.imshow(out1.reshape(var_ny, var_nx),cmap='gray',origin = 'lower')
#    plt.show()

    
####OK, up to here I have the data.  Now I need to put it into a useful form, preferably something like the SunPy MAP data structure   
